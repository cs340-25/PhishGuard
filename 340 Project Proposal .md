**Phishing Email Detector**  
   
**PhishGuard**

Trevor Olson  
Zebulon Mcknight   
Tyler Herren  
Sarvvesh Vinod Kumar 

	Our project will be a phishing email detector using a machine learning model we make. Our goal is to cross reference content and metadata of emails with known suspicious emails and mark messages as safe or suspicious. We’re primarily motivated by an interest to learn in the fields of both artificial intelligence and cyber security while producing a product that can help the average person. This idea isn’t entirely novel, but we intend to improve upon some aspects of existing phishing detectors. Our goal is to have a comparable detection rate to commercial products like gmail’s detection but have it easily available for anyone to use no matter what email they have. Tyler, Trevor, and Zebulon all worked on a cybersecurity project in previous classes, specifically including frontend, backend, and database work. 

	Our primary customer base would be the general public and specifically people unfamiliar with cyber security best practices. We hope to help protect those who may not know how to detect a scam themselves. While our product wouldn’t be revolutionary it would be an easy way for our customers to prevent malware or stolen data from a phishing attack. While other products exist, they often add difficulty to the users life by having to use specific accounts such as gmail. Personally, a success for us would include a comparable accuracy to existing systems while providing a useful and easy user experience. If our model has a high accuracy rate and consistently detects phishing email we will know our customers are getting the benefits our product provides. 

	From a developer standpoint our software will read in emails, including the text content, any links or attachments, and metadata. This data will be fed into a machine learning algorithm trained on existing email data to determine the chance of the email being malicious. Upon determining this, the software will either flag the email as safe or dangerous, and recommend the user the appropriate action. This means we will need at least 3-4 major components to tie this software together. A frontend for receiving data and presenting results, a backend machine learning algorithm to process data, a database for storing reference material and user input, and a backend infrastructure for connecting all existing features. At the moment we intend to build the frontend in React, and database using PostgreSQL. The machine learning model will be made using  Python, and for convenient web features Node.js or Java with the Spring Boot framework will most likely be used for the rest of the backend infrastructure. We will definitely be taking features from existing implementations, especially for building our dataset of emails. In the future a google extension so users can more easily use our product would be an enhancement customers would value. We will test our machine learning model by using 80% of the phishing data for training purposes and the other 20% will be used to test the accuracy of the model and then make adjustments as necessary. The web app will be tested by locally hosting it and potentially using a tool like JMeter to stress test before deployment. 

	As mentioned above, three of our group members have worked on cybersecurity projects before, including similar full stack work with React, Java, and PostgreSQL. None of our members have significant experience in machine learning, so that will present a challenge to the team, but by using familiar technologies we expect to be able to complete the project successfully. Given that not all tasks associated with the project are equally challenging and time intensive, and that not all features are parallelizable, member roles will have to be flexible for the group to be maximally productive. While every member of the team will contribute to each part using the people who have previous experience with the tools and languages will ensure we can complete the project in a timely manner. So Zebulon will likely have a larger role in the frontend with React and Tyler will do the same with Java with all members having rotating roles and responsibilities. 

We believe we can feasibly complete this project in the time allotted, especially if we communicate and collaborate effectively. We will need to stay in touch throughout the week, and will likely meet for group work at least once a week to realign goals and make sure everyones on track. There are no legal, ethical, or social concerns with our project other than how we present it to customers. It could be a concern if we presented our product as a perfect detection system, this could cause harm to our consumers if they believed our response could never be wrong and opened an email that was incorrectly identified as safe it could cause harm to them or their property. To make sure these concerns are minimized as possible we will train our model to err on the side of caution and also make sure our users know that the product can make mistakes. There are several free datasets of known phishing emails that we can use for training our model so resources shouldn’t be an issue. If we find that the software is too time consuming to develop, there are a few clear ways to cut development time. The primary feature is the machine learning algorithm, so given that feature being completed we can cut time by limiting the functionality or portability of our user interface. Our goal would be a cross platform plugin for existing email services, but given a time crunch we could require a more work intensive interface which would require the user to submit emails themselves for individual checking. This would be inconvenient, but effective nonetheless. 

Tentative Schedule:   
Week 						      Tasks 

| F16-F22 | Gather data, begin designing core algorithm, start repository and assign initial tasks  |
| :---- | :---- |
| F23-M1 | Ensure all features (perhaps excluding core algorithm) are connected. Ensure we can send data between, front, back, and database features.  |
| M2-M8 | Complete draft of and begin testing core algorithm |
| M9-M15 | Refine core algorithm and other features  |
| M16-M22 | Refine core algorithm and other features  |
| M23-M29 | Determine final frontend implementation depending on current progress.  |
| M30-A5 | Connect algorithm to chosen interface, begin testing with real emails through entire service  |
| A6-A12 | Complete final edits and ensure all features are working as expected. |
| A13-15 | Submit the project and write reflection.  |

